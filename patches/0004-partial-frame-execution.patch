From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Fujisan Build <noreply@example.com>
Date: Wed, 14 Aug 2025 00:00:00 +0000
Subject: [PATCH] Add partial frame execution API for fine-grained debugging

This patch adds libatari800_execute_cycles() function to enable executing
a specific number of CPU cycles rather than a full frame. This allows
for precise breakpoint detection within frame boundaries, improving
debugging accuracy from ~29,000 cycle granularity to ~500 cycle granularity.

The function properly handles scanline boundaries and frame transitions
to maintain emulation accuracy while providing fine-grained control.

diff --git a/src/libatari800/api.c b/src/libatari800/api.c
index 1234567..abcdef0 100644
--- a/src/libatari800/api.c
+++ b/src/libatari800/api.c
@@ -24,6 +24,7 @@
 #include "../binload.h"
 #include "util.h"
+#include "pokey.h"
 #include "libatari800/main.h"
 #include "libatari800/cpu_crash.h"
 #include "libatari800/init.h"
@@ -520,6 +521,67 @@ int libatari800_set_sio_patch_enabled(int enabled)
 	return prev;
 }
 
+/* Execute a specific number of CPU cycles for fine-grained debugging control */
+int libatari800_execute_cycles(int target_cycles)
+{
+	extern int ANTIC_xpos;
+	extern int ANTIC_ypos;
+	int cycles_executed = 0;
+	
+	/* Ensure we have a reasonable cycle count */
+	if (target_cycles <= 0 || target_cycles > 30000) {
+		return 0;
+	}
+	
+	/* Save current position */
+	int start_xpos = ANTIC_xpos;
+	
+	/* Execute cycles in small chunks to maintain accuracy */
+	while (cycles_executed < target_cycles) {
+		int remaining = target_cycles - cycles_executed;
+		int to_execute = remaining > 114 ? 114 : remaining;  /* One scanline max */
+		
+		/* Check if we need to handle scanline boundaries */
+		if (ANTIC_xpos + to_execute >= 114) {
+			/* Execute to end of current scanline */
+			int to_scanline_end = 114 - ANTIC_xpos;
+			if (to_scanline_end > 0) {
+				CPU_GO(ANTIC_xpos + to_scanline_end);
+				cycles_executed += to_scanline_end;
+				ANTIC_xpos += to_scanline_end;
+			}
+			
+			/* Handle scanline transition if needed */
+			if (ANTIC_xpos >= 114) {
+				ANTIC_xpos = 0;
+				ANTIC_ypos++;
+				
+				/* Check for frame boundary */
+				if (ANTIC_ypos >= 312) {  /* PAL frame height */
+					/* We've reached end of frame, stop here */
+					break;
+				}
+				
+				/* Process scanline housekeeping */
+				POKEY_Scanline();
+			}
+		} else {
+			/* Execute within current scanline */
+			CPU_GO(ANTIC_xpos + to_execute);
+			cycles_executed += to_execute;
+			ANTIC_xpos += to_execute;
+		}
+		
+		/* Safety check to prevent infinite loops */
+		if (cycles_executed > target_cycles * 2) {
+			break;
+		}
+	}
+	
+	return cycles_executed;
+}
+
 /*
 vim:ts=4:sw=4:
 */
diff --git a/src/libatari800/libatari800.h b/src/libatari800/libatari800.h
index 1234567..abcdef0 100644
--- a/src/libatari800/libatari800.h
+++ b/src/libatari800/libatari800.h
@@ -319,6 +319,9 @@ void libatari800_set_disk_activity_callback(void (*callback)(int drive, int ope
 int libatari800_get_sio_patch_enabled(void);
 int libatari800_set_sio_patch_enabled(int enabled);
 
+/* Partial frame execution for fine-grained debugging */
+int libatari800_execute_cycles(int target_cycles);
+
 #endif /* LIBATARI800_H_ */
 
 /* ****************************************************************** */
From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Fujisan Developer <fujisan@atari>
Date: Fri, 15 Nov 2025 00:00:00 -0800
Subject: [PATCH] Add NetSIO re-initialization protection for emulator restarts

Add initialization tracking to prevent netsio_init() from running multiple
times during emulator restarts (e.g., machine type changes). This maintains
the NetSIO connection across libatari800_exit()/init() cycles.

The new netsio_initialized flag:
- Set to 1 after successful initialization
- Causes early return in netsio_init() if already initialized  
- Prevents duplicate socket/thread/pipe creation
- Keeps NetSIO connection alive during emulator restarts

Also adds netsio_shutdown() function for potential future explicit cleanup,
but does NOT call it automatically. The NetSIO connection persists for the
lifetime of the process, avoiding disconnect/reconnect cycles that break
FujiNet-PC communication during machine type changes.

Benefits:
- No socket closure during restarts  
- No disconnect notification to FujiNet-PC
- Connection remains active across restart cycles
- OS handles cleanup when process exits
---
 src/netsio.c | 71 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 71 insertions(+)

diff --git a/src/netsio.c b/src/netsio.c
index feb3f1c5..708fa5b5 100644
--- a/src/netsio.c
+++ b/src/netsio.c
@@ -30,6 +30,8 @@ static void send_block_to_fujinet(const uint8_t *block, size_t len);
 
 /* Flag to know when netsio is enabled */
 volatile int netsio_enabled = 0;
+/* Flag to track if NetSIO has been initialized (prevents re-initialization) */
+static int netsio_initialized = 0;
 /* Holds sync to fujinet-pc incremented number */
 uint8_t netsio_sync_num = 0;
 /* if we have heard from fujinet-pc or not */
@@ -209,6 +211,14 @@ int netsio_init(uint16_t port) {
     pthread_t rx_thread;
     int broadcast = 1;
 
+    /* Skip re-initialization if already initialized (during emulator restarts) */
+    if (netsio_initialized) {
+#ifdef DEBUG
+        Log_print("netsio: already initialized, skipping re-initialization");
+#endif
+        return 0;
+    }
+
     /* create emulator <-> netsio FIFOs */
     if (pipe(fds0) < 0)
     {
@@ -294,6 +304,12 @@ int netsio_init(uint16_t port) {
     }
     pthread_detach(rx_thread);
 
+    /* Mark as initialized to prevent re-initialization */
+    netsio_initialized = 1;
+#ifdef DEBUG
+    Log_print("netsio: initialization complete");
+#endif
+
     return 0;
 }
 
@@ -726,3 +742,55 @@ static void *fujinet_rx_thread(void *arg) {
     }
     return NULL;
 }
+
+/* Shutdown NetSIO subsystem and clean up resources */
+void netsio_shutdown(void) {
+#ifdef DEBUG
+    Log_print("netsio: shutting down...");
+#endif
+
+    /* Send disconnect notification to FujiNet-PC (if connected) */
+    if (netsio_enabled) {
+        uint8_t pkt = NETSIO_DEVICE_DISCONNECTED;
+        send_to_fujinet(&pkt, 1);
+#ifdef DEBUG
+        Log_print("netsio: sent disconnect notification");
+#endif
+    }
+
+    /* Close UDP socket - this will cause fujinet_rx_thread's recvfrom() to fail and exit */
+    if (sockfd >= 0) {
+#ifdef DEBUG
+        Log_print("netsio: closing socket %d", sockfd);
+#endif
+        close(sockfd);
+        sockfd = -1;
+    }
+
+    /* Close FIFO pipes */
+    if (fds0[0] >= 0) {
+        close(fds0[0]);
+        fds0[0] = -1;
+    }
+    if (fds0[1] >= 0) {
+        close(fds0[1]);
+        fds0[1] = -1;
+    }
+
+    /* Reset global state variables */
+    netsio_enabled = 0;
+    netsio_initialized = 0;  /* Allow re-initialization after shutdown */
+    netsio_sync_num = 0;
+    fujinet_known = 0;
+    netsio_sync_wait = 0;
+    netsio_cmd_state = 0;
+    netsio_next_write_size = 0;
+
+    /* Clear address info */
+    memset(&fujinet_addr, 0, sizeof(fujinet_addr));
+    fujinet_addr_len = sizeof(fujinet_addr);
+
+#ifdef DEBUG
+    Log_print("netsio: shutdown complete");
+#endif
+}
-- 
2.39.2


--- netsio.c.original	2025-07-30 09:06:59.606696761 -0400
+++ netsio.c	2025-07-26 16:23:36.283800899 -0400
@@ -16,6 +16,7 @@
 #include <sys/socket.h>
 #include <sys/ioctl.h>
 #include <netinet/in.h>
+#include <arpa/inet.h>
 #include <fcntl.h>
 #include <time.h>
 #include "netsio.h"
@@ -199,6 +200,9 @@
     send_to_fujinet(packet, len + 2);
 }
 
+/* Store configured port for use in response routing */
+static uint16_t netsio_port = 9997;
+
 /* Initialize NetSIO:
 *   - connect to FujiNet socket
 *   - create FIFO
@@ -208,6 +212,9 @@
     struct sockaddr_in addr;
     pthread_t rx_thread;
     int broadcast = 1;
+    
+    /* Store the configured port */
+    netsio_port = port;
 
     /* create emulator <-> netsio FIFOs */
     if (pipe(fds0) < 0)
@@ -239,6 +246,7 @@
     addr.sin_len = sizeof(addr); /* Only needed on macOS/BSD systems */
 #endif
     
+    /* Set up address for binding to port 9997 (original server architecture) */
     addr.sin_family = AF_INET;
     addr.sin_port = htons(port);
     addr.sin_addr.s_addr = htonl(INADDR_ANY);
@@ -255,15 +263,39 @@
 #endif
     }
 
-    /* Bind to the socket on requested port */
-    if (bind(sockfd, (struct sockaddr *)&addr, sizeof(addr)) < 0)
-    {
-#ifdef DEBUG
-        Log_print("netsio bind socket error");
+    /* Allow port reuse so both FujiNet-PC and emulator can use port 9997 */
+    int reuse = 1;
+    if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse)) < 0) {
+        Log_print("NetSIO: Warning - failed to set SO_REUSEADDR");
+    }
+    
+#ifdef SO_REUSEPORT
+    if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEPORT, &reuse, sizeof(reuse)) < 0) {
+        Log_print("NetSIO: Warning - failed to set SO_REUSEPORT");
+    }
 #endif
-        close(sockfd);
-        return -1;
+
+    /* Bind to configured port for receiving from FujiNet-PC */
+    if (bind(sockfd, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+        Log_print("NetSIO: Failed to bind to port %d - trying port sharing", port);
+        
+        /* If bind fails, it might mean FujiNet-PC is using the port */
+        /* In this case, we'll use a different port for receiving */
+        addr.sin_port = 0; /* Let system assign port */
+        if (bind(sockfd, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+            Log_print("NetSIO: Failed to bind to any port");
+            close(sockfd);
+            return -1;
+        }
+        
+        socklen_t addr_len = sizeof(addr);
+        getsockname(sockfd, (struct sockaddr *)&addr, &addr_len);
+        Log_print("NetSIO: Bound to fallback port %d", ntohs(addr.sin_port));
+    } else {
+        Log_print("NetSIO: Successfully bound to port %d", port);
     }
+    
+    Log_print("NetSIO: Waiting for FujiNet-PC to discover and connect...");
 
     /* spawn receiver thread */
     if (pthread_create(&rx_thread, NULL, fujinet_rx_thread, NULL) != 0)
@@ -278,6 +310,35 @@
     return 0;
 }
 
+/* Shutdown NetSIO subsystem */
+void netsio_shutdown(void) {
+    /* Set flag to indicate NetSIO is disabled */
+    netsio_enabled = 0;
+    
+    /* Close socket if it's open */
+    if (sockfd >= 0) {
+        close(sockfd);
+        sockfd = -1;
+    }
+    
+    /* Close FIFO pipes if they're open */
+    if (fds0[0] >= 0) {
+        close(fds0[0]);
+        fds0[0] = -1;
+    }
+    if (fds0[1] >= 0) {
+        close(fds0[1]);
+        fds0[1] = -1;
+    }
+    
+    /* Reset state variables */
+    fujinet_known = 0;
+    netsio_sync_wait = 0;
+    netsio_cmd_state = 0;
+    netsio_next_write_size = 0;
+    netsio_sync_num = 0;
+}
+
 /* Called when a command frame with sync response is sent to FujiNet */
 void netsio_wait_for_sync(void)
 {
@@ -486,12 +547,25 @@
 #endif
             continue;
         }
-        fujinet_known = 1;
         
-        /* Update the address length to the correct size for future sends */
-        if (fujinet_addr.ss_family == AF_INET) {
-            /* For IPv4, use sizeof sockaddr_in */
-            fujinet_addr_len = sizeof(struct sockaddr_in);
+#ifdef DEBUG_NETSIO_VERBOSE
+        Log_print("NetSIO: Received %zd bytes from FujiNet-PC: %02X %02X %02X...", n, 
+                 (n > 0) ? buf[0] : 0, (n > 1) ? buf[1] : 0, (n > 2) ? buf[2] : 0);
+#endif
+        
+        /* Set up FujiNet-PC address for responses (only on first packet) */
+        if (!fujinet_known) {
+            fujinet_known = 1;
+            
+            if (fujinet_addr.ss_family == AF_INET) {
+                /* For IPv4, use sizeof sockaddr_in */
+                fujinet_addr_len = sizeof(struct sockaddr_in);
+                
+                /* Fix destination port - FujiNet-PC listens on configured port, not the source port */
+                struct sockaddr_in *addr_in = (struct sockaddr_in *)&fujinet_addr;
+                addr_in->sin_port = htons(netsio_port);
+                Log_print("NetSIO: Set response destination to port %d", netsio_port);
+            }
         }
 
         /* Every packet must be at least one byte (the command) */
@@ -523,6 +597,7 @@
                 Log_print("netsio: recv: device connected");
 #endif
                 netsio_enabled = 1;
+                Log_print("NetSIO: *** DEVICE_CONNECTED received - netsio_enabled = %d ***", netsio_enabled);
                 break;
             }
 
@@ -538,6 +613,10 @@
             case NETSIO_ALIVE_REQUEST:
             {
                 uint8_t r = NETSIO_ALIVE_RESPONSE;
+                struct sockaddr_in *addr_in = (struct sockaddr_in *)&fujinet_addr;
+                /* Commented out to reduce message spam - this happens very frequently
+                Log_print("NetSIO: Sending ALIVE_RESPONSE (C5) to %s:%d", 
+                         inet_ntoa(addr_in->sin_addr), ntohs(addr_in->sin_port)); */
                 send_to_fujinet(&r, 1);
 #ifdef DEBUG2
                 Log_print("netsio: recv: IT'S ALIVE!");

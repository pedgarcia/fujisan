From: Fujisan Developer
Date: 2025-07-31
Subject: Add disk management and activity API to libatari800

This patch adds missing libatari800 API functions for disk management,
disk activity monitoring, and SIO patch control. These APIs are required
by the Fujisan Qt-based frontend.

Compatible with atari800 commit: 575a943b3523bf0f5c9b73ba8641d83cac672f24

--- src/libatari800/api.c	2025-07-31 17:00:00.000000000 -0400
+++ src/libatari800/api.c	2025-07-31 17:00:00.000000000 -0400
@@ -40,6 +40,7 @@
 #include "memory.h"
 #include "screen.h"
 #include "sio.h"
+#include "esc.h"
 #include "../sound.h"
 #include "util.h"
 #include "libatari800/main.h"
@@ -50,6 +51,9 @@
 #include "libatari800/statesav.h"
 
 
+/* Callback pointer for disk activity notifications */
+void (*disk_activity_callback)(int drive, int operation) = NULL;
+
 #ifdef HAVE_SETJMP
 jmp_buf libatari800_cpu_crash;
 #endif
@@ -251,6 +255,30 @@
 	return SIO_Mount(diskno, filename, readonly);
 }
 
+/** Dismount disk image from drive
+ * 
+ * Remove the disk image from the specified drive. The drive status will be set to
+ * SIO_NO_DISK and the filename will be cleared to "Empty".
+ * 
+ * @param diskno drive number (1-8 for D1: through D8:)
+ */
+void libatari800_dismount_disk_image(int diskno)
+{
+	SIO_Dismount(diskno);
+}
+
+/** Disable disk drive
+ * 
+ * Dismount any disk image and disable the drive completely. The drive status will be set to
+ * SIO_OFF and the filename will be set to "Off".
+ * 
+ * @param diskno drive number (1-8 for D1: through D8:)
+ */
+void libatari800_disable_drive(int diskno)
+{
+	SIO_DisableDrive(diskno);
+}
+
 
 /** Restart emulation using file
  * 
@@ -489,6 +517,92 @@
 	Atari800_Exit(0);
 }
 
+/** Get current disk activity state (polling method)
+ * 
+ * Checks if there is currently disk I/O activity happening and returns
+ * information about the active drive and operation type.
+ * 
+ * @param drive pointer to receive drive number (1-8) if activity detected
+ * @param operation pointer to receive operation type (0=read, 1=write) if activity detected  
+ * @param time_remaining pointer to receive frames remaining for LED display if activity detected
+ * 
+ * @retval 1 if disk activity is currently happening
+ * @retval 0 if no disk activity
+ */
+int libatari800_get_disk_activity(int *drive, int *operation, int *time_remaining)
+{
+	if (SIO_last_op_time > 0) {
+		if (drive) *drive = SIO_last_drive;
+		if (operation) *operation = SIO_last_op;
+		if (time_remaining) *time_remaining = SIO_last_op_time;
+		return 1;
+	}
+	return 0;
+}
+
+/** Set callback for real-time disk activity events
+ * 
+ * Sets a callback function that will be called whenever disk I/O activity
+ * occurs. This provides real-time notification without polling.
+ * 
+ * Note: The callback is called from within the emulation loop, so it should
+ * be kept lightweight and avoid blocking operations.
+ * 
+ * @param callback function to call when disk activity occurs, or NULL to disable
+ *                 callback receives: drive (1-8), operation (0=read, 1=write)
+ */
+void libatari800_set_disk_activity_callback(void (*callback)(int drive, int operation))
+{
+	disk_activity_callback = callback;
+}
+
+/** Get current SIO patch status
+ * 
+ * Returns the current state of the SIO patch which controls disk access speed.
+ * When enabled (1), disk access is fast and bypasses realistic timing delays.
+ * When disabled (0), disk access uses realistic hardware timing (slower).
+ * 
+ * @retval 1 if SIO patch (fast disk access) is enabled
+ * @retval 0 if SIO patch is disabled (realistic timing)
+ */
+int libatari800_get_sio_patch_enabled()
+{
+	return ESC_enable_sio_patch;
+}
+
+/** Set SIO patch status
+ * 
+ * Controls the SIO patch which affects disk access speed.
+ * - enabled=1: Fast disk access (bypasses realistic timing)
+ * - enabled=0: Realistic hardware timing (slower but authentic)
+ * 
+ * @param enabled 1 to enable fast disk access, 0 to use realistic timing
+ * 
+ * @retval previous SIO patch state (1 or 0)
+ */
+int libatari800_set_sio_patch_enabled(int enabled)
+{
+	int previous_state = ESC_enable_sio_patch;
+	ESC_enable_sio_patch = enabled ? TRUE : FALSE;
+	return previous_state;
+}
+
 /*
 vim:ts=4:sw=4:
 */
--- src/libatari800/libatari800.h	2025-07-31 17:00:00.000000000 -0400
+++ src/libatari800/libatari800.h	2025-07-31 17:00:00.000000000 -0400
@@ -119,6 +119,18 @@
 } input_template_t;
 
 
+/* Disk management functions */
+void libatari800_dismount_disk_image(int driveNumber);
+void libatari800_disable_drive(int driveNumber);
+
+/* Disk activity monitoring */
+int libatari800_get_disk_activity(int *drive, int *operation, int *time_remaining);
+typedef void (*disk_activity_callback_t)(int driveNumber, int operation);
+void libatari800_set_disk_activity_callback(disk_activity_callback_t callback);
+
+/* SIO patch control */
+int libatari800_get_sio_patch_enabled(void);
+int libatari800_set_sio_patch_enabled(int enabled);
+
 #define STATESAV_MAX_SIZE 210000
 
 /* byte offsets into output_template.state array of groups of data
--- src/sio.c	2025-07-31 17:00:00.000000000 -0400
+++ src/sio.c	2025-07-31 17:00:00.000000000 -0400
@@ -161,6 +161,9 @@
 int SIO_last_drive;
 int SIO_last_sector;
 
+/* External callback for disk activity notifications */
+extern void (*disk_activity_callback)(int drive, int operation);
+
 char SIO_status[256];
 
 /* Serial I/O emulation support */
@@ -669,6 +672,10 @@
 	SIO_last_op = SIO_LAST_READ;
 	SIO_last_op_time = 1;
 	SIO_last_drive = unit + 1;
+	
+	/* Notify callback if set */
+	if (disk_activity_callback)
+		disk_activity_callback(unit + 1, SIO_LAST_READ);
 	/* FIXME: what sector size did the user expect? */
 	size = SeekSector(unit, sector);
 	if (image_type[unit] == IMAGE_TYPE_PRO) {
@@ -850,6 +857,10 @@
 	SIO_last_op = SIO_LAST_WRITE;
 	SIO_last_op_time = 1;
 	SIO_last_drive = unit + 1;
+	
+	/* Notify callback if set */
+	if (disk_activity_callback)
+		disk_activity_callback(unit + 1, SIO_LAST_WRITE);
 #ifdef VAPI_WRITE_ENABLE 	
  	if (image_type[unit] == IMAGE_TYPE_VAPI) {
 		vapi_additional_info_t *info;
@@ -1414,6 +1425,10 @@
 		SIO_last_op = SIO_LAST_WRITE;
 		SIO_last_op_time = 10;
 		SIO_last_drive = unit + 1;
+		
+		/* Notify callback if set */
+		if (disk_activity_callback)
+			disk_activity_callback(unit + 1, SIO_LAST_WRITE);
 		return 'A';
 	case 0x52:				/* Read */
 	case 0xD2:				/* xf551 hispeed */
@@ -1455,6 +1470,10 @@
 		SIO_last_op = SIO_LAST_READ;
 		SIO_last_op_time = 10;
 		SIO_last_drive = unit + 1;
+		
+		/* Notify callback if set */
+		if (disk_activity_callback)
+			disk_activity_callback(unit + 1, SIO_LAST_READ);
 		return 'A';
 	case 0x53:				/* Status */
 	case 0xD3:				/* xf551 hispeed */
From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Fujisan Build <noreply@example.com>
Date: Wed, 6 Aug 2025 00:00:00 +0000
Subject: [PATCH] Add disk management API and activity callbacks to libatari800

This patch adds comprehensive disk management functions to the libatari800 API
including mount/unmount operations, disk activity callbacks, and integrates
the callbacks with SIO operations for real-time disk LED monitoring.

diff --git a/src/libatari800/api.c b/src/libatari800/api.c
--- a/src/libatari800/api.c
+++ b/src/libatari800/api.c
@@ -29,6 +29,10 @@
 #include <string.h>
 
 /* Atari800 includes */
+#include "libatari800.h"
 #include "atari.h"
+#include "../sio.h"
+#include "../esc.h"
+#include "akey.h"
 #include "afile.h"
 #include "../input.h"
@@ -490,6 +494,55 @@ void libatari800_exit() {
 	Atari800_Exit(0);
 }
 
+/* Disk activity callback function pointer */
+void (*disk_activity_callback)(int drive, int operation) = NULL;
+
+/* Disk management functions */
+int libatari800_mount_disk(int drive_num, const char *filename, int read_only)
+{
+	if (drive_num < 1 || drive_num > 8 || filename == NULL)
+		return FALSE;
+	
+	/* Use SIO_Mount with read_only flag properly mapped */
+	if (SIO_Mount(drive_num, filename, read_only ? TRUE : FALSE))
+		return TRUE;
+	
+	return FALSE;
+}
+
+void libatari800_unmount_disk(int drive_num)
+{
+	if (drive_num < 1 || drive_num > 8)
+		return;
+	
+	SIO_Dismount(drive_num);
+}
+
+void libatari800_disable_drive(int drive_num)
+{
+	if (drive_num < 1 || drive_num > 8)
+		return;
+	
+	SIO_DisableDrive(drive_num);
+}
+
+void libatari800_set_disk_activity_callback(void (*callback)(int drive, int operation))
+{
+	disk_activity_callback = callback;
+}
+
+int libatari800_get_sio_patch_enabled(void)
+{
+	return ESC_enable_sio_patch;
+}
+
+int libatari800_set_sio_patch_enabled(int enabled)
+{
+	int prev = ESC_enable_sio_patch;
+	ESC_enable_sio_patch = enabled;
+	return prev;
+}
+
 /*
 vim:ts=4:sw=4:
 */
diff --git a/src/libatari800/libatari800.h b/src/libatari800/libatari800.h
--- a/src/libatari800/libatari800.h
+++ b/src/libatari800/libatari800.h
@@ -305,6 +305,16 @@ void libatari800_restore_state(emulator_state_t *state);
 
 void libatari800_exit();
 
+/* Disk management functions */
+int libatari800_mount_disk(int drive_num, const char *filename, int read_only);
+void libatari800_unmount_disk(int drive_num);
+void libatari800_disable_drive(int drive_num);
+void libatari800_set_disk_activity_callback(void (*callback)(int drive, int operation));
+
+/* SIO patch control functions */
+int libatari800_get_sio_patch_enabled(void);
+int libatari800_set_sio_patch_enabled(int enabled);
+
 #endif /* LIBATARI800_H_ */
 
 /* ****************************************************************** */
diff --git a/src/sio.c b/src/sio.c
--- a/src/sio.c
+++ b/src/sio.c
@@ -74,6 +74,11 @@ static int image_type[SIO_MAX_DRIVES];
 #define IMAGE_TYPE_ATR  1
 #define IMAGE_TYPE_PRO  2
 #define IMAGE_TYPE_VAPI 3
+
+#ifdef LIBATARI800
+extern void (*disk_activity_callback)(int drive, int operation);
+#endif
+
 static FILE *disk[SIO_MAX_DRIVES] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
 static int sectorcount[SIO_MAX_DRIVES];
 static int sectorsize[SIO_MAX_DRIVES];
@@ -665,6 +670,12 @@ static UBYTE ReadSector(int unit, int sector, UBYTE *buffer)
 	SIO_last_op = SIO_LAST_READ;
 	SIO_last_op_time = 1;
 	SIO_last_drive = unit + 1;
+#ifdef LIBATARI800
+	/* Call disk activity callback for real-time LED updates */
+	if (disk_activity_callback) {
+		disk_activity_callback(SIO_last_drive, SIO_LAST_READ);
+	}
+#endif
 	/* FIXME: what sector size did the user expect? */
 	size = SeekSector(unit, sector);
 	if (image_type[unit] == IMAGE_TYPE_PRO) {
@@ -846,6 +857,12 @@ static UBYTE WriteSector(int unit, int sector, const UBYTE *buffer)
 	SIO_last_op = SIO_LAST_WRITE;
 	SIO_last_op_time = 1;
 	SIO_last_drive = unit + 1;
+#ifdef LIBATARI800
+	/* Call disk activity callback for real-time LED updates */
+	if (disk_activity_callback) {
+		disk_activity_callback(SIO_last_drive, SIO_LAST_WRITE);
+	}
+#endif
 #ifdef VAPI_WRITE_ENABLE 	
  	if (image_type[unit] == IMAGE_TYPE_VAPI) {
 		if (fseek(disk[unit], (long) sector * sectorsize[unit], SEEK_SET) != 0)
@@ -1406,6 +1423,12 @@ static UBYTE CommandFrame(void)
 		SIO_last_op = SIO_LAST_WRITE;
 		SIO_last_op_time = 10;
 		SIO_last_drive = unit + 1;
+#ifdef LIBATARI800
+		/* Call disk activity callback for real-time LED updates */
+		if (disk_activity_callback) {
+			disk_activity_callback(SIO_last_drive, SIO_LAST_WRITE);
+		}
+#endif
 		return 'A';
 	case 0x52:				/* Read */
 		if (SIO_drive_status[unit] == SIO_OFF)
@@ -1443,6 +1466,12 @@ static UBYTE CommandFrame(void)
 		SIO_last_op = SIO_LAST_READ;
 		SIO_last_op_time = 10;
 		SIO_last_drive = unit + 1;
+#ifdef LIBATARI800
+		/* Call disk activity callback for real-time LED updates */
+		if (disk_activity_callback) {
+			disk_activity_callback(SIO_last_drive, SIO_LAST_READ);
+		}
+#endif
 		return 'A';
 	case 0x53:				/* Status */
 		if (SIO_drive_status[unit] == SIO_OFF)